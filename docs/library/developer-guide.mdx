---
title: Developer Guide
description: Fastest path to build your first AFK agent and harden it for production.
---

This page is optimized for immediate implementation with AFK (Agent Forge Kit).

## First 20 Minutes

<Steps>
  <Step title="Install dependencies">
    <CodeGroup>

```bash uv
uv pip install afk pydantic
```

```bash pip
pip install afk pydantic
```

    </CodeGroup>
  </Step>

  <Step title="Configure environment">

```bash
export AFK_LLM_ADAPTER=openai
export AFK_LLM_MODEL=gpt-4.1-mini
export AFK_LLM_API_KEY=your_key_here
```

  </Step>

  <Step title="Run first example script">

```bash
python 01_minimal_chat_agent.py
```

  </Step>

  <Step title="Add safety before side effects">Move to `02_policy_with_hitl.py` before enabling write/delete/action tools.</Step>
</Steps>

<Tip>
Create local script files using the embedded examples in <a href="/library/examples/index">Examples</a>, then run them with the filenames shown in each accordion.
</Tip>

## Recommended Build Order

<CardGroup cols={2}>
  <Card title="1) Minimal Agent" href="/library/examples/index#01-minimal-chat-agent" icon="play-circle">
    Start with one agent, one typed tool, one request.
  </Card>
  <Card title="2) Policy + HITL" href="/library/examples/index#02-policy-with-hitl" icon="shield">
    Add approval gates before side effects.
  </Card>
  <Card title="3) Subagents" href="/library/examples/index#03-subagents-with-router" icon="workflow">
    Route to specialized workers only when needed.
  </Card>
  <Card title="4) Resume + Compact" href="/library/examples/index#04-resume-and-compact" icon="database">
    Persist state and verify restart behavior.
  </Card>
  <Card title="5) Direct LLM Layer" href="/library/examples/index#05-direct-llm-structured-output" icon="cpu">
    Use structured outputs and request-level controls.
  </Card>
  <Card title="6) Tool Security" href="/library/examples/index#06-tool-registry-security" icon="lock">
    Enforce path/command/network restrictions.
  </Card>
</CardGroup>

## Public Import Patterns

```python
from afk.agents import Agent
from afk.core import Runner, RunnerConfig
from afk.llms import create_llm
from afk.tools import tool
from afk.memory import create_memory_store_from_env
```

<Warning>
Do not import from `src/...` in app code. Use public imports (`afk.*`) only.
</Warning>

## Core Workflow

1. Define a minimal `Agent` and validate end-to-end response flow.
2. Add typed tools with strict argument schemas.
3. Add policy decisions for risky tool calls.
4. Add sandbox and output limits for tool safety.
5. Add memory persistence and resume verification.
6. Add tests/evals for regressions.

## Common Implementation Patterns

<Tabs>
  <Tab title="Agent + Typed Tool">

```python
from pydantic import BaseModel, Field
from afk.agents import Agent
from afk.tools import tool

class LookupArgs(BaseModel):
    query: str = Field(min_length=1)

@tool(
    args_model=LookupArgs,
    name="lookup",
    description="Look up canonical product/internal documentation content by query.",
)
def lookup(args: LookupArgs) -> dict[str, str]:
    return {"query": args.query}

agent = Agent(
    model="gpt-4.1-mini",
    instructions="Use lookup when external data is needed.",
    tools=[lookup],
)
```

  </Tab>
  <Tab title="Runner Controls">

```python
from afk.core import Runner, RunnerConfig

runner = Runner(
    config=RunnerConfig(
        interaction_mode="headless",
        sanitize_tool_output=True,
    )
)
```

  </Tab>
</Tabs>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Unknown adapter">
    <ul>
      <li>Verify <code>AFK_LLM_ADAPTER</code>.</li>
      <li>Check available adapters with <code>afk.llms.available_llm_adapters()</code>.</li>
    </ul>
  </Accordion>

  <Accordion title="Model routes to wrong provider">
    <p>Use explicit prefixes when needed:</p>
    <ul>
      <li><code>openai/gpt-4.1-mini</code></li>
      <li><code>anthropic/claude-sonnet-4</code></li>
    </ul>
  </Accordion>

  <Accordion title="Run pauses waiting for approval/input">
    <ul>
      <li>Check <code>RunnerConfig.interaction_mode</code>.</li>
      <li>For non-headless mode, ensure <code>interaction_provider</code> is configured.</li>
      <li>Set timeout/fallback behavior in <code>RunnerConfig</code>.</li>
    </ul>
  </Accordion>

  <Accordion title="Tool call denied">
    <ul>
      <li>Inspect policy decision (<code>PolicyEngine</code> rules).</li>
      <li>Verify sandbox profile allowlists.</li>
    </ul>
  </Accordion>
</AccordionGroup>

## Read Next (By Need)

- [Architecture](/library/architecture)
- [Tool Call Lifecycle](/library/tool-call-lifecycle)
- [Security Model](/library/security-model)
- [API Reference](/library/api-reference)
